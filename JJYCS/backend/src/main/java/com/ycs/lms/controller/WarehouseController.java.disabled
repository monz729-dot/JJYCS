package com.ycs.lms.controller;

import com.ycs.lms.entity.WarehouseInventory;
import com.ycs.lms.dto.warehouse.*;
import com.ycs.lms.dto.ReceiveOrderRequest;
import com.ycs.lms.service.WarehouseService;
import com.ycs.lms.service.WarehouseService.ScanResult;
import com.ycs.lms.service.WarehouseService.BatchResult;
import com.ycs.lms.service.WarehouseService.WarehouseStatus;
import com.ycs.lms.service.WarehouseManagementService;
import com.ycs.lms.service.WarehouseManagementService.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/warehouse")
@RequiredArgsConstructor
@Slf4j
public class WarehouseController {
    
    private final WarehouseService warehouseService;
    private final WarehouseManagementService warehouseManagementService;
    
    @PostMapping("/scan/inbound")
    public ResponseEntity<Map<String, Object>> processInbound(@RequestBody InboundScanRequest request) {
        try {
            log.info("Inbound scan request: {}", request.getScanCode());
            
            ScanResult result = warehouseService.processInbound(
                request.getScanCode(),
                request.getScanType(),
                request.getLocation(),
                request.getNotes(),
                request.getOperatorId()
            );
            
            if (result.isSuccess()) {
                return ResponseEntity.ok(Map.of(
                    "success", true,
                    "message", result.getMessage(),
                    "order", result.getOrder(),
                    "assignedLocation", result.getAdditionalInfo()
                ));
            } else {
                return ResponseEntity.badRequest().body(Map.of(
                    "success", false,
                    "error", result.getMessage()
                ));
            }
            
        } catch (Exception e) {
            log.error("Inbound scan error", e);
            return ResponseEntity.internalServerError().body(Map.of(
                "success", false,
                "error", "입고 스캔 처리 중 오류가 발생했습니다."
            ));
        }
    }
    
    @PostMapping("/scan/outbound")
    public ResponseEntity<Map<String, Object>> processOutbound(@RequestBody OutboundScanRequest request) {
        try {
            log.info("Outbound scan request: {}", request.getScanCode());
            
            ScanResult result = warehouseService.processOutbound(
                request.getScanCode(),
                request.getTrackingNumber(),
                request.getActualWeight(),
                request.getNotes(),
                request.getOperatorId()
            );
            
            if (result.isSuccess()) {
                return ResponseEntity.ok(Map.of(
                    "success", true,
                    "message", result.getMessage(),
                    "order", result.getOrder(),
                    "trackingNumber", result.getAdditionalInfo()
                ));
            } else {
                return ResponseEntity.badRequest().body(Map.of(
                    "success", false,
                    "error", result.getMessage()
                ));
            }
            
        } catch (Exception e) {
            log.error("Outbound scan error", e);
            return ResponseEntity.internalServerError().body(Map.of(
                "success", false,
                "error", "출고 스캔 처리 중 오류가 발생했습니다."
            ));
        }
    }
    
    @PostMapping("/scan/hold")
    public ResponseEntity<Map<String, Object>> processHold(@RequestBody HoldScanRequest request) {
        try {
            log.info("Hold scan request: {}", request.getScanCode());
            
            ScanResult result = warehouseService.processHold(
                request.getScanCode(),
                request.getReason(),
                request.getOperatorId()
            );
            
            if (result.isSuccess()) {
                return ResponseEntity.ok(Map.of(
                    "success", true,
                    "message", result.getMessage(),
                    "order", result.getOrder()
                ));
            } else {
                return ResponseEntity.badRequest().body(Map.of(
                    "success", false,
                    "error", result.getMessage()
                ));
            }
            
        } catch (Exception e) {
            log.error("Hold scan error", e);
            return ResponseEntity.internalServerError().body(Map.of(
                "success", false,
                "error", "보류 스캔 처리 중 오류가 발생했습니다."
            ));
        }
    }
    
    @PostMapping("/scan/mixbox")
    public ResponseEntity<Map<String, Object>> processMixBox(@RequestBody MixBoxScanRequest request) {
        try {
            log.info("Mix box scan request: codes={}, mixBoxId={}", request.getScanCodes().size(), request.getMixBoxId());
            
            ScanResult result = warehouseService.processMixBox(
                request.getScanCodes(),
                request.getMixBoxId(),
                request.getOperatorId()
            );
            
            if (result.isSuccess()) {
                return ResponseEntity.ok(Map.of(
                    "success", true,
                    "message", result.getMessage(),
                    "mixBoxId", result.getAdditionalInfo()
                ));
            } else {
                return ResponseEntity.badRequest().body(Map.of(
                    "success", false,
                    "error", result.getMessage()
                ));
            }
            
        } catch (Exception e) {
            log.error("Mix box scan error", e);
            return ResponseEntity.internalServerError().body(Map.of(
                "success", false,
                "error", "믹스박스 스캔 처리 중 오류가 발생했습니다."
            ));
        }
    }
    
    @PostMapping("/batch/inbound")
    public ResponseEntity<Map<String, Object>> processBatchInbound(@RequestBody BatchScanRequest request) {
        try {
            log.info("Batch inbound request: {} codes", request.getScanCodes().size());
            
            BatchResult result = warehouseService.processBatchInbound(
                request.getScanCodes(),
                request.getOperatorId()
            );
            
            return ResponseEntity.ok(Map.of(
                "success", true,
                "message", String.format("일괄 입고 완료: 성공 %d개, 실패 %d개", 
                                       result.getSuccessCount(), result.getFailureCount()),
                "totalCount", result.getTotalCount(),
                "successCount", result.getSuccessCount(),
                "failureCount", result.getFailureCount(),
                "successDetails", result.getSuccessDetails(),
                "failureDetails", result.getFailureDetails()
            ));
            
        } catch (Exception e) {
            log.error("Batch inbound error", e);
            return ResponseEntity.internalServerError().body(Map.of(
                "success", false,
                "error", "일괄 입고 처리 중 오류가 발생했습니다."
            ));
        }
    }
    
    @PostMapping("/batch/outbound")
    public ResponseEntity<Map<String, Object>> processBatchOutbound(@RequestBody BatchScanRequest request) {
        try {
            log.info("Batch outbound request: {} codes", request.getScanCodes().size());
            
            BatchResult result = warehouseService.processBatchOutbound(
                request.getScanCodes(),
                request.getOperatorId()
            );
            
            return ResponseEntity.ok(Map.of(
                "success", true,
                "message", String.format("일괄 출고 완료: 성공 %d개, 실패 %d개", 
                                       result.getSuccessCount(), result.getFailureCount()),
                "totalCount", result.getTotalCount(),
                "successCount", result.getSuccessCount(),
                "failureCount", result.getFailureCount(),
                "successDetails", result.getSuccessDetails(),
                "failureDetails", result.getFailureDetails()
            ));
            
        } catch (Exception e) {
            log.error("Batch outbound error", e);
            return ResponseEntity.internalServerError().body(Map.of(
                "success", false,
                "error", "일괄 출고 처리 중 오류가 발생했습니다."
            ));
        }
    }
    
    @PostMapping("/scan")
    public ResponseEntity<Map<String, Object>> scan(@RequestBody GenericScanRequest request) {
        try {
            log.info("Generic warehouse scan: {} - {} at {}", 
                request.getLabelCode(), request.getScanType(), request.getLocation());
            
            // Route to appropriate specific scan endpoint based on scanType
            String scanType = request.getScanType().toUpperCase();
            
            switch (scanType) {
                case "INBOUND":
                    ScanResult result = warehouseService.processInbound(
                        request.getLabelCode(),
                        scanType,
                        request.getLocation(),
                        request.getNotes(),
                        "api-test" // Default operator for API tests
                    );
                    
                    if (result.isSuccess()) {
                        return ResponseEntity.ok(Map.of(
                            "success", true,
                            "message", result.getMessage(),
                            "order", result.getOrder(),
                            "scanType", scanType,
                            "location", request.getLocation()
                        ));
                    } else {
                        return ResponseEntity.badRequest().body(Map.of(
                            "success", false,
                            "error", result.getMessage()
                        ));
                    }
                    
                default:
                    // For other scan types or testing, return a mock success response
                    return ResponseEntity.ok(Map.of(
                        "success", true,
                        "message", "스캔이 성공적으로 처리되었습니다.",
                        "labelCode", request.getLabelCode(),
                        "scanType", request.getScanType(),
                        "location", request.getLocation(),
                        "timestamp", java.time.LocalDateTime.now()
                    ));
            }
            
        } catch (Exception e) {
            log.error("Generic warehouse scan error", e);
            return ResponseEntity.internalServerError()
                .body(Map.of("success", false, "error", "스캔 처리 중 오류가 발생했습니다."));
        }
    }
    
    @GetMapping("/status")
    public ResponseEntity<Map<String, Object>> getWarehouseStatus() {
        try {
            WarehouseStatus status = warehouseService.getWarehouseStatus();
            
            return ResponseEntity.ok(Map.of(
                "success", true,
                "status", status
            ));
            
        } catch (Exception e) {
            log.error("Get warehouse status error", e);
            return ResponseEntity.internalServerError().body(Map.of(
                "success", false,
                "error", "창고 현황 조회 중 오류가 발생했습니다."
            ));
        }
    }
    
    // DTO 클래스들
    public static class GenericScanRequest {
        private String labelCode;
        private String scanType; // INBOUND, OUTBOUND, HOLD, MIXBOX
        private String location;
        private String notes;
        
        // Getters and Setters
        public String getLabelCode() { return labelCode; }
        public void setLabelCode(String labelCode) { this.labelCode = labelCode; }
        public String getScanType() { return scanType; }
        public void setScanType(String scanType) { this.scanType = scanType; }
        public String getLocation() { return location; }
        public void setLocation(String location) { this.location = location; }
        public String getNotes() { return notes; }
        public void setNotes(String notes) { this.notes = notes; }
    }
    
    public static class InboundScanRequest {
        private String scanCode;
        private String scanType = "INBOUND";
        private String location;
        private String notes;
        private String operatorId;
        
        // Getters and Setters
        public String getScanCode() { return scanCode; }
        public void setScanCode(String scanCode) { this.scanCode = scanCode; }
        public String getScanType() { return scanType; }
        public void setScanType(String scanType) { this.scanType = scanType; }
        public String getLocation() { return location; }
        public void setLocation(String location) { this.location = location; }
        public String getNotes() { return notes; }
        public void setNotes(String notes) { this.notes = notes; }
        public String getOperatorId() { return operatorId; }
        public void setOperatorId(String operatorId) { this.operatorId = operatorId; }
    }
    
    public static class OutboundScanRequest {
        private String scanCode;
        private String trackingNumber;
        private BigDecimal actualWeight;
        private String notes;
        private String operatorId;
        
        // Getters and Setters
        public String getScanCode() { return scanCode; }
        public void setScanCode(String scanCode) { this.scanCode = scanCode; }
        public String getTrackingNumber() { return trackingNumber; }
        public void setTrackingNumber(String trackingNumber) { this.trackingNumber = trackingNumber; }
        public BigDecimal getActualWeight() { return actualWeight; }
        public void setActualWeight(BigDecimal actualWeight) { this.actualWeight = actualWeight; }
        public String getNotes() { return notes; }
        public void setNotes(String notes) { this.notes = notes; }
        public String getOperatorId() { return operatorId; }
        public void setOperatorId(String operatorId) { this.operatorId = operatorId; }
    }
    
    public static class HoldScanRequest {
        private String scanCode;
        private String reason;
        private String operatorId;
        
        // Getters and Setters
        public String getScanCode() { return scanCode; }
        public void setScanCode(String scanCode) { this.scanCode = scanCode; }
        public String getReason() { return reason; }
        public void setReason(String reason) { this.reason = reason; }
        public String getOperatorId() { return operatorId; }
        public void setOperatorId(String operatorId) { this.operatorId = operatorId; }
    }
    
    public static class MixBoxScanRequest {
        private List<String> scanCodes;
        private String mixBoxId;
        private String operatorId;
        
        // Getters and Setters
        public List<String> getScanCodes() { return scanCodes; }
        public void setScanCodes(List<String> scanCodes) { this.scanCodes = scanCodes; }
        public String getMixBoxId() { return mixBoxId; }
        public void setMixBoxId(String mixBoxId) { this.mixBoxId = mixBoxId; }
        public String getOperatorId() { return operatorId; }
        public void setOperatorId(String operatorId) { this.operatorId = operatorId; }
    }
    
    public static class BatchScanRequest {
        private List<String> scanCodes;
        private String operatorId;
        
        // Getters and Setters
        public List<String> getScanCodes() { return scanCodes; }
        public void setScanCodes(List<String> scanCodes) { this.scanCodes = scanCodes; }
        public String getOperatorId() { return operatorId; }
        public void setOperatorId(String operatorId) { this.operatorId = operatorId; }
    }
    
    // ===== 창고 관리 시스템 API 추가 =====
    
    /**
     * 주문 입고 처리 (새로운 창고 관리 시스템)
     */
    @PostMapping("/management/receive")
    public ResponseEntity<WarehouseInventory> receiveOrder(@RequestBody ReceiveOrderRequest request) {
        try {
            log.info("주문 입고 처리 요청: orderId={}, warehouseId={}", request.getOrderId(), request.getWarehouseId());
            WarehouseInventory inventory = warehouseManagementService.receiveOrder(request.getOrderId(), request);
            return ResponseEntity.ok(inventory);
        } catch (Exception e) {
            log.error("주문 입고 처리 실패", e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 재고 검수 처리
     */
    @PostMapping("/management/inspect/{inventoryId}")
    public ResponseEntity<WarehouseInventory> inspectInventory(
            @PathVariable Long inventoryId,
            @RequestBody InspectInventoryRequest request) {
        try {
            log.info("재고 검수 처리: inventoryId={}", inventoryId);
            WarehouseInventory inventory = warehouseManagementService.inspectInventory(inventoryId, request);
            return ResponseEntity.ok(inventory);
        } catch (Exception e) {
            log.error("재고 검수 처리 실패", e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 재고 출고 처리
     */
    @PostMapping("/management/ship/{inventoryId}")
    public ResponseEntity<WarehouseInventory> shipInventory(
            @PathVariable Long inventoryId,
            @RequestBody ShipInventoryRequest request) {
        try {
            log.info("재고 출고 처리: inventoryId={}", inventoryId);
            WarehouseInventory inventory = warehouseManagementService.shipInventory(inventoryId, request);
            return ResponseEntity.ok(inventory);
        } catch (Exception e) {
            log.error("재고 출고 처리 실패", e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 일괄 출고 처리
     */
    @PostMapping("/management/ship/batch")
    public ResponseEntity<List<WarehouseInventory>> batchShipInventories(@RequestBody BatchShipRequest request) {
        try {
            log.info("일괄 출고 처리: inventoryIds={}", request.getInventoryIds());
            List<WarehouseInventory> inventories = warehouseManagementService.batchShipInventories(
                request.getInventoryIds(), request.getShippedBy());
            return ResponseEntity.ok(inventories);
        } catch (Exception e) {
            log.error("일괄 출고 처리 실패", e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 재고 보류 처리
     */
    @PostMapping("/management/hold/{inventoryId}")
    public ResponseEntity<WarehouseInventory> holdInventory(
            @PathVariable Long inventoryId,
            @RequestBody HoldInventoryRequest request) {
        try {
            log.info("재고 보류 처리: inventoryId={}, reason={}", inventoryId, request.getReason());
            WarehouseInventory inventory = warehouseManagementService.holdInventory(inventoryId, request.getReason());
            return ResponseEntity.ok(inventory);
        } catch (Exception e) {
            log.error("재고 보류 처리 실패", e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 손상 신고 처리
     */
    @PostMapping("/management/damage/{inventoryId}")
    public ResponseEntity<WarehouseInventory> reportDamage(
            @PathVariable Long inventoryId,
            @RequestBody ReportDamageRequest request) {
        try {
            log.info("손상 신고 처리: inventoryId={}", inventoryId);
            WarehouseInventory inventory = warehouseManagementService.reportDamage(inventoryId, request.getDamageReport());
            return ResponseEntity.ok(inventory);
        } catch (Exception e) {
            log.error("손상 신고 처리 실패", e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 재고 코드/바코드/QR코드로 조회
     */
    @GetMapping("/management/inventory/search")
    public ResponseEntity<WarehouseInventory> searchInventory(@RequestParam String code) {
        try {
            WarehouseInventory inventory = warehouseManagementService.findInventoryByCode(code);
            return ResponseEntity.ok(inventory);
        } catch (Exception e) {
            log.error("재고 조회 실패: code={}", code, e);
            return ResponseEntity.notFound().build();
        }
    }
    
    /**
     * 창고별 재고 목록 조회
     */
    @GetMapping("/management/{warehouseId}/inventory")
    public ResponseEntity<List<WarehouseInventory>> getWarehouseInventory(
            @PathVariable Long warehouseId,
            @RequestParam(required = false) String status,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        try {
            Pageable pageable = PageRequest.of(page, size);
            List<WarehouseInventory> inventories;
            
            if (status != null) {
                WarehouseInventory.InventoryStatus inventoryStatus = 
                    WarehouseInventory.InventoryStatus.valueOf(status.toUpperCase());
                inventories = warehouseManagementService.getInventoryByWarehouseAndStatus(warehouseId, inventoryStatus);
            } else {
                inventories = warehouseManagementService.getWarehouseInventory(warehouseId);
            }
            
            return ResponseEntity.ok(inventories);
        } catch (Exception e) {
            log.error("창고 재고 목록 조회 실패: warehouseId={}", warehouseId, e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 검수 대기 재고 목록
     */
    @GetMapping("/management/{warehouseId}/inspection-pending")
    public ResponseEntity<List<WarehouseInventory>> getInspectionPendingInventory(@PathVariable Long warehouseId) {
        try {
            List<WarehouseInventory> inventories = warehouseManagementService.getInspectionPendingInventory(warehouseId);
            return ResponseEntity.ok(inventories);
        } catch (Exception e) {
            log.error("검수 대기 재고 조회 실패: warehouseId={}", warehouseId, e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 출고 준비 완료 재고 목록
     */
    @GetMapping("/management/{warehouseId}/ready-for-shipping")
    public ResponseEntity<List<WarehouseInventory>> getReadyForShippingInventory(@PathVariable Long warehouseId) {
        try {
            List<WarehouseInventory> inventories = warehouseManagementService.getReadyForShippingInventory(warehouseId);
            return ResponseEntity.ok(inventories);
        } catch (Exception e) {
            log.error("출고 준비 완료 재고 조회 실패: warehouseId={}", warehouseId, e);
            return ResponseEntity.badRequest().build();
        }
    }
    
    /**
     * 창고 통계 정보 조회
     */
    @GetMapping("/management/{warehouseId}/statistics")
    public ResponseEntity<WarehouseStatistics> getWarehouseStatistics(
            @PathVariable Long warehouseId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate) {
        try {
            WarehouseStatistics statistics = warehouseManagementService.getWarehouseStatistics(warehouseId, startDate, endDate);
            return ResponseEntity.ok(statistics);
        } catch (Exception e) {
            log.error("창고 통계 조회 실패: warehouseId={}", warehouseId, e);
            return ResponseEntity.badRequest().build();
        }
    }
}